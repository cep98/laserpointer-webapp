<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Laserpointer Control mit Klebekanten</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: none;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 10px;
    }
    .color {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid white;
    }
    #laserButton {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20%;
      width: 120px;
      height: 120px;
      border-radius: 60px;
      background: red;
      border: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="500" height="500"></canvas>
  <div id="controls">
    <div class="color" style="background:red" onclick="setColor('red')"></div>
    <div class="color" style="background:green" onclick="setColor('green')"></div>
    <div class="color" style="background:blue" onclick="setColor('blue')"></div>
    <div class="color" style="background:yellow" onclick="setColor('yellow')"></div>
  </div>
  <button id="laserButton"></button>

  <script>
    const socket = io();
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let color = "red";
    let laserActive = false;
    let calibrated = false;
    let alpha0 = 0, beta0 = 0;
    let x = canvas.width / 2;
    let y = canvas.height / 2;
    const scaling = 5;

    let currentAlpha = null, currentBeta = null;
    let edgeState = { left: false, right: false, top: false, bottom: false };
    let lastX = canvas.width / 2;
    let lastY = canvas.height / 2;

    document.getElementById("laserButton").addEventListener("touchstart", e => {
      e.preventDefault();
      laserActive = true;
      if (!calibrated && currentAlpha !== null && currentBeta !== null) {
        alpha0 = currentAlpha;
        beta0 = currentBeta;
        calibrated = true;
      }
    });

    document.getElementById("laserButton").addEventListener("touchend", e => {
      e.preventDefault();
      laserActive = false;
    });

    function setColor(c) {
      color = c;
    }

    socket.on("edgeHit", data => {
      if (data.side) {
        edgeState[data.side] = true;
      }
    });

    window.addEventListener("deviceorientation", e => {
      currentAlpha = e.alpha;
      currentBeta = e.beta;

      if (laserActive && calibrated) {
        let relAlpha = currentAlpha - alpha0;
        let relBeta = currentBeta - beta0;

        let proposedX = canvas.width / 2 - relAlpha * scaling;
        let proposedY = canvas.height / 2 - relBeta * scaling;

        // Begrenzung erzwingen
        if (proposedX < 0) proposedX = 0;
        if (proposedX > canvas.width) proposedX = canvas.width;
        if (proposedY < 0) proposedY = 0;
        if (proposedY > canvas.height) proposedY = canvas.height;

        // Rekalibrierung NUR wenn vorher edgeState aktiv und jetzt klar zurÃ¼ck
        if (edgeState.left && proposedX > 30 && lastX <= 5) {
          alpha0 = currentAlpha + canvas.width / 2 / scaling;
          edgeState.left = false;
        }
        if (edgeState.right && proposedX < canvas.width - 30 && lastX >= canvas.width - 5) {
          alpha0 = currentAlpha - canvas.width / 2 / scaling;
          edgeState.right = false;
        }
        if (edgeState.top && proposedY > 30 && lastY <= 5) {
          beta0 = currentBeta + canvas.height / 2 / scaling;
          edgeState.top = false;
        }
        if (edgeState.bottom && proposedY < canvas.height - 30 && lastY >= canvas.height - 5) {
          beta0 = currentBeta - canvas.height / 2 / scaling;
          edgeState.bottom = false;
        }

        x = proposedX;
        y = proposedY;
        lastX = x;
        lastY = y;

        socket.emit("draw", { x, y, color });
      }
    });

    socket.on("draw", data => {
      ctx.fillStyle = data.color;
      ctx.beginPath();
      ctx.arc(data.x, data.y, 4, 0, 2 * Math.PI);
      ctx.fill();
    });

    socket.on("clear", () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
  </script>
</body>
</html>
