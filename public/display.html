<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display (Pixi+MeshLine)</title>
  <style>
    body { margin:0; background:#000 }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; font-family:sans-serif; font-size:14px; opacity:0.6; z-index:10;
    }
    #canvas-container {
      width:1024px; height:1024px;
      margin: auto;
      position: relative;
      top:50%; transform:translateY(-50%);
    }
  </style>
</head>
<body>
  <div id="version">v4.0 (Pixi+MeshLine)</div>
  <div id="canvas-container"></div>

  <!-- PixiJS & pixi-meshline -->
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.2.4/dist/browser/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pixi-meshline@5.4.0/dist/pixi-meshline.umd.js"></script>
  <!-- Socket.IO Client -->
  <script src="/socket.io/socket.io.js"></script>

  <script>
  // 1) PIXI-Setup
  const app = new PIXI.Application({
    width: 1024,
    height: 1024,
    backgroundColor: 0x000000,
    antialias: true,
    resolution: window.devicePixelRatio || 1
  });
  document.getElementById("canvas-container").appendChild(app.view);

  // Container für Linien & Pulse
  const linesContainer = new PIXI.Container();
  const pulseGraphics  = new PIXI.Graphics();
  app.stage.addChild(linesContainer, pulseGraphics);

  // 2) Socket.IO + Identify
  const socket = io();
  socket.emit("identify", { role:"display", deviceId: null });

  // 3) Admin-Settings
  let MAX_H   = 20,
      MAX_V   = 20,
      SMOOTH  = 0.15,
      MIN_W   = 5,
      MAX_W   = 12;

  socket.on("updateSettings", cfg => {
    if (typeof cfg.maxH   === "number") MAX_H  = cfg.maxH;
    if (typeof cfg.maxV   === "number") MAX_V  = cfg.maxV;
    if (typeof cfg.smooth === "number") SMOOTH = cfg.smooth;
    if (typeof cfg.minW   === "number") MIN_W  = cfg.minW;
    if (typeof cfg.maxW   === "number") MAX_W  = cfg.maxW;
  });

  // 4) State pro Gerät
  const state = {}; 
  // state[deviceId] = {
  //   alpha0,beta0, smooth:{x,y,t},
  //   lastW, meshLine, material, mesh, lastColor, lastLight
  // };

  function parseLight(hsl) {
    const m = hsl.match(/,\s*(\d+)%\)/);
    return m ? +m[1] : 50;
  }

  // 5) clear-Handler
  socket.on("clear", () => {
    linesContainer.removeChildren();
    pulseGraphics.clear();
    for (let id in state) {
      delete state[id];
    }
  });

  // 6) motion-Handler
  socket.on("motion", ({ alpha, beta, color, isDrawing, deviceId }) => {
    if (typeof alpha !== "number" || !deviceId) return;
    const now = performance.now();
    const CX = app.renderer.width/2, CY = app.renderer.height/2;

    // Init bei erstem Draw
    let s = state[deviceId];
    if (!s) {
      s = state[deviceId] = {
        alpha0: null,
        beta0: null,
        smooth:{ x:CX, y:CY, t:now },
        lastW:(MIN_W+MAX_W)/2,
        meshLine: new PIXI.mesh.MeshLine(),
        material: null,
        mesh: null,
        lastColor: color,
        lastLight: parseLight(color)
      };
    }

    // Update Farbe / Light
    s.lastColor = color;
    s.lastLight = parseLight(color);

    // bei erstem drücken kalibrieren
    if (isDrawing && s.alpha0 === null) {
      s.alpha0 = alpha;
      s.beta0  = beta;
    }
    if (s.alpha0 === null) return;

    // Winkel-Delta + Wrap
    let dA = alpha - s.alpha0;
    if (dA > 180)  dA -= 360;
    if (dA < -180) dA += 360;
    let dB = beta - s.beta0;

    // clamp
    dA = Math.max(-MAX_H, Math.min(MAX_H, dA));
    dB = Math.max(-MAX_V, Math.min(MAX_V, dB));

    // auf Canvas mappen
    const x = CX - (dA/MAX_H)*CX;
    const y = CY - (dB/MAX_V)*CY;

    // smoothing
    const sp = s.smooth;
    sp.x += (x - sp.x) * SMOOTH;
    sp.y += (y - sp.y) * SMOOTH;

    // Geschwindigkeit
    const dt    = (now - sp.t)/1000;
    const dx    = sp.x - (s.prevX||sp.x);
    const dy    = sp.y - (s.prevY||sp.y);
    const speed = dt>0 ? Math.hypot(dx,dy)/dt : 0;
    sp.t = now; s.prevX = sp.x; s.prevY = sp.y;

    // Roh-Position für Puls
    // wird direkt aus sp.x/sp.y gelesen

    // Zeichnen
    if (isDrawing) {
      // dynamische Breite
      const norm = Math.min(1, speed/2000);
      const w2   = MAX_W - (MAX_W - MIN_W)*norm;
      const w1   = s.lastW;
      s.lastW    = w2;

      // Material & Mesh bei erstem Segment anlegen
      if (!s.material) {
        const colHex = PIXI.utils.string2hex(color);
        s.material = new PIXI.mesh.MeshLineMaterial({
          color: colHex,
          lineWidth: w2,             // Startbreite
          resolution: { x:1024, y:1024 }
        });
        s.mesh = new PIXI.Mesh(s.meshLine, s.material);
        linesContainer.addChild(s.mesh);
      }

      // Punkte & Breiten pushen
      const pts    = s.meshLine.points.concat([sp.x, sp.y]);
      const widths = (s.meshLine.widths||[]).concat([w1, w2]);
      // MeshLine aktualisieren
      s.meshLine.setPoints(pts, false, widths);
      // Material-Breite updaten (für Caps)
      s.material.uniforms.lineWidth = w2;
    }

  });


  // 7) Render-Loop für Puls
  let pulse = 0, growing = true;
  app.ticker.add(() => {
    // Pulse
    pulse += growing?0.2:-0.2;
    if (pulse > 2) growing = false;
    if (pulse < 0) growing = true;

    // Clear pulses
    pulseGraphics.clear();

    // Für jedes Gerät pulsierenden Punkt zeichnen
    for (let id in state) {
      const s  = state[id],
            sp = s.smooth,
            col = PIXI.utils.string2hex(s.lastColor||"#ffffff"),
            light = s.lastLight||50,
            r = s.lastW/2 + pulse;

      // Fill circle
      pulseGraphics.beginFill(col);
      pulseGraphics.drawCircle(sp.x, sp.y, r);
      pulseGraphics.endFill();

      // Weißer Ring bei dunkler Farbe
      if (light < 20) {
        pulseGraphics.lineStyle(3, 0xffffff, 1);
        pulseGraphics.drawCircle(sp.x, sp.y, r + 3);
      }
    }
  });
  </script>
</body>
</html>
