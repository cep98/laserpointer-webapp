<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.15</title>
  <style>
    body { margin:0; background:black }
    canvas { display:block; margin:auto; background:black }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.15 (bezier + dynamic width)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.emit("identify", { role: "display", deviceId: null });

    const c   = document.getElementById("canvas"),
          ctx = c.getContext("2d"),
          CX  = c.width/2, CY = c.height/2;

    // Admin-Settings
    let MAX_H=20, MAX_V=20, SMOOTH=0.15;
    socket.on("updateSettings", ({ maxH, maxV, smooth }) => {
      if (typeof maxH==="number") MAX_H=maxH;
      if (typeof maxV==="number") MAX_V=maxV;
      if (typeof smooth==="number") SMOOTH=smooth;
    });

    // State pro Gerät
    const alpha0    = {},
          beta0     = {},
          rawPos    = {},
          smoothPos = {},
          prevPos   = {},  // vorherige glatte Pos
          prev2Pos  = {},  // zweite vorherige (für Bézier)
          lastTime  = {},
          lastCol   = {},
          lastLight = {};

    const segments = []; // {p0,p1,p2,color,width}

    ctx.lineCap="round";
    ctx.lineJoin="round";

    function parseLight(hsl){
      const m=hsl.match(/hsl\(\s*\d+,\s*\d+%,\s*(\d+)%\)/);
      return m?+m[1]:50;
    }

    socket.on("clear",()=>{
      segments.length=0;
      ctx.clearRect(0,0,c.width,c.height);
      Object.keys(alpha0).forEach(k=>delete alpha0[k]);
      Object.keys(beta0).forEach(k=>delete beta0[k]);
      Object.keys(rawPos).forEach(k=>delete rawPos[k]);
      Object.keys(smoothPos).forEach(k=>delete smoothPos[k]);
      Object.keys(prevPos).forEach(k=>delete prevPos[k]);
      Object.keys(prev2Pos).forEach(k=>delete prev2Pos[k]);
      Object.keys(lastTime).forEach(k=>delete lastTime[k]);
      Object.keys(lastCol).forEach(k=>delete lastCol[k]);
      Object.keys(lastLight).forEach(k=>delete lastLight[k]);
    });

    socket.on("motion",({alpha,beta,color,isDrawing,deviceId})=>{
      if(!deviceId||typeof alpha!=="number")return;
      const now=performance.now();

      // Farbe/Helligkeit
      lastCol[deviceId]=color;
      lastLight[deviceId]=parseLight(color);

      // Kalibrierung
      if(isDrawing && !(deviceId in alpha0)){
        alpha0[deviceId]=alpha;
        beta0 [deviceId]=beta;
        rawPos[deviceId]={x:CX,y:CY};
        smoothPos[deviceId]={x:CX,y:CY};
        prevPos[deviceId]={x:CX,y:CY};
        prev2Pos[deviceId]={x:CX,y:CY};
        lastTime[deviceId]=now;
        return;
      }
      if(!(deviceId in alpha0))return;

      // Winkel-Delta + Wrap
      let dA=alpha-alpha0[deviceId];
      if(dA>180)dA-=360;
      if(dA<-180)dA+=360;
      let dB=beta-beta0[deviceId];

      // Clamp
      dA=Math.max(-MAX_H,Math.min(MAX_H,dA));
      dB=Math.max(-MAX_V,Math.min(MAX_V,dB));

      // Map roh
      const rawX=CX-(dA/MAX_H)*CX,
            rawY=CY-(dB/MAX_V)*CY;

      // Smooth
      const s=smoothPos[deviceId];
      s.x+=(rawX-s.x)*SMOOTH;
      s.y+=(rawY-s.y)*SMOOTH;

      // Geschwindigkeit px/s
      const prevR=rawPos[deviceId];
      const dt=(now-lastTime[deviceId])/1000;
      const speed=dt>0?Math.hypot(s.x-prevR.x,s.y-prevR.y)/dt:0;
      lastTime[deviceId]=now;

      // Neues Segment (Bézier) nur beim Zeichnen
      if(isDrawing){
        // Normierte Geschwindigkeit [0..1]
        const norm=Math.min(1,speed/2000);
        const maxW=12,minW=2;
        const w=maxW-(maxW-minW)*norm;

        const p2={x:s.x,y:s.y},
              p1=prevPos[deviceId],
              p0=prev2Pos[deviceId];

        // Erst ab drei Punkten Bézier
        if(prev2Pos[deviceId]){
          segments.push({p0,p1,p2,color,lastW:w});
        }

        // Shift history
        prev2Pos[deviceId]=prevPos[deviceId];
        prevPos[deviceId]={x:s.x,y:s.y};
      }

      rawPos[deviceId]={x:rawX,y:rawY};
    });

    // Render Loop
    let pulse=0,grow=true;
    (function render(){
      ctx.clearRect(0,0,c.width,c.height);

      // Zeichne alle Bézier-Segmente
      for(const sgt of segments){
        ctx.strokeStyle=sgt.color;
        ctx.lineWidth=sgt.lastW;
        ctx.beginPath();
        ctx.moveTo(sgt.p0.x,sgt.p0.y);
        ctx.quadraticCurveTo(sgt.p1.x,sgt.p1.y,sgt.p2.x,sgt.p2.y);
        ctx.stroke();
      }

      // Pulsation
      pulse+=grow?0.2:-0.2;
      if(pulse>2)grow=false;
      if(pulse<0)grow=true;

      // Pulsierende Punkte
      for(const id in smoothPos){
        const {x,y}=smoothPos[id],
              col=lastCol[id]||"#f00",
              light=lastLight[id]||50,
              // Punktgröße aus letztem Segment
              lastSeg=segments.filter(s=>s.color===col).slice(-1)[0],
              baseW=lastSeg?lastSeg.lastW:6,
              r=baseW/2 + pulse;

        ctx.beginPath();
        ctx.arc(x,y,r,0,2*Math.PI);
        ctx.fillStyle=col;
        ctx.fill();

        if(light<20){
          ctx.beginPath();
          ctx.arc(x,y,r+3,0,2*Math.PI);
          ctx.strokeStyle="#fff";
          ctx.lineWidth=3;
          ctx.stroke();
        }
      }

      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
