<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.0</title>
  <style>
    body { margin:0; background:#000; }
    #canvas { display:block; margin:auto; background:#000; }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.0</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const c = document.getElementById("canvas"),
          ctx = c.getContext("2d");
    const MAX_ANGLE = 20,
          CX = c.width/2,
          CY = c.height/2;

    let alpha0, beta0, calibrated=false;
    let lastX=null, lastY=null;
    const segments = [];

    // Zeichne permanent
    function render() {
      ctx.clearRect(0,0,c.width,c.height);
      // alle Linien zeichnen
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      segments.forEach(s=>{
        ctx.strokeStyle = s.color;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(s.x1,s.y1);
        ctx.lineTo(s.x2,s.y2);
        ctx.stroke();
      });
      // Pulsierender Punkt
      if (lastX!=null) {
        const r = 4 + Math.sin(Date.now()/150)*2;
        ctx.beginPath();
        ctx.arc(lastX,lastY,r,0,2*Math.PI);
        ctx.fillStyle = segments.length? segments[segments.length-1].color : "#fff";
        ctx.fill();
      }
      requestAnimationFrame(render);
    }
    render();

    // Incoming motion
    socket.on("motion",({alpha,beta,color,isDrawing})=>{
      if (!calibrated && isDrawing) {
        alpha0 = alpha; beta0 = beta;
        calibrated = true;
      }
      if (!calibrated) return;
      // rel
      let dA = alpha - alpha0,
          dB = beta  - beta0;
      // wrap
      if (dA>180) dA-=360; if(dA<-180) dA+=360;
      // clamp
      dA = Math.max(-MAX_ANGLE,Math.min(MAX_ANGLE,dA));
      dB = Math.max(-MAX_ANGLE,Math.min(MAX_ANGLE,dB));
      // map
      const x = CX + (dA/MAX_ANGLE)*CX,
            y = CY + (dB/MAX_ANGLE)*CY;
      if (isDrawing) {
        if (lastX!=null && lastY!=null) {
          segments.push({ x1:lastX, y1:lastY, x2:x, y2:y, color });
        }
        lastX = x; lastY = y;
      } else {
        lastX = x; lastY = y;
      }
    });

    // optional clear
    socket.on("clear",()=>{ segments.length=0; lastX=lastY=null; });
  </script>
</body>
</html>
