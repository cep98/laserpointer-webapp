<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.13</title>
  <style>
    body { margin:0; background:#000; overflow:hidden }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; font-family:sans-serif;
      font-size:14px; opacity:0.6; z-index:10;
    }
    canvas { display:block; margin:auto; background:#000 }
  </style>
</head>
<body>
  <div id="version">v3.13 (dyn. Breite)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  const socket = io();
  socket.emit("identify",{ role:"display", deviceId:null });

  const c   = document.getElementById("canvas"),
        ctx = c.getContext("2d"),
        CX  = c.width/2,
        CY  = c.height/2;

  // Standard-Settings
  let MAX_H  = 20,
      MAX_V  = 20,
      MIN_W  = 2,
      MAX_W  = 12,
      SMOOTH = 0.15;

  socket.on("updateSettings", cfg => {
    if (typeof cfg.maxH   === "number") MAX_H  = cfg.maxH;
    if (typeof cfg.maxV   === "number") MAX_V  = cfg.maxV;
    if (typeof cfg.minW   === "number") MIN_W  = cfg.minW;
    if (typeof cfg.maxW   === "number") MAX_W  = cfg.maxW;
    if (typeof cfg.smooth === "number") SMOOTH = cfg.smooth;
    console.log("Settings:",{MAX_H,MAX_V,MIN_W,MAX_W,SMOOTH});
  });

  // Pro Device-State
  const alpha0  = {},  // Kalibriernullpunkte
        beta0   = {},
        rawPos  = {},
        lastT   = {},
        segments = {},  // deviceId → [Segments]
        lastC   = {},
        lastL   = {};

  function parseLight(hsl) {
    const m = hsl.match(/,\s*(\d+)%\)/);
    return m ? +m[1] : 50;
  }

  // löschen
  socket.on("clear",() => {
    ctx.clearRect(0,0,c.width,c.height);
    for(let id in segments) segments[id]=[];
  });

  // incoming motion
  socket.on("motion", ({alpha,beta,color,isDrawing,deviceId})=>{
    if(typeof alpha!=="number"||!deviceId) return;
    const now = performance.now(),
          CX2 = CX, CY2 = CY;

    lastC[deviceId] = color;
    lastL[deviceId] = parseLight(color);

    // init state-arrays
    if(!(deviceId in rawPos)){
      rawPos[deviceId] = {x:CX2,y:CY2};
      lastT[deviceId]  = now;
      segments[deviceId] = [];
      alpha0[deviceId] = null;
      beta0 [deviceId] = null;
    }

    // kalibrieren
    if(isDrawing && alpha0[deviceId]===null){
      alpha0[deviceId] = alpha;
      beta0 [deviceId] = beta;
    }
    if(alpha0[deviceId]===null) return;

    // winkel-delta + wrap
    let dA = alpha - alpha0[deviceId];
    if(dA>180) dA-=360;
    if(dA<-180)dA+=360;
    let dB = beta - beta0[deviceId];
    dA = Math.max(-MAX_H,Math.min(MAX_H,dA));
    dB = Math.max(-MAX_V,Math.min(MAX_V,dB));

    // map to canvas
    const x = CX2 - (dA/MAX_H)*CX2;
    const y = CY2 - (dB/MAX_V)*CY2;

    // speed & width
    const prev = rawPos[deviceId];
    const dt   = (now - lastT[deviceId])/1000;
    const dist = Math.hypot(x-prev.x, y-prev.y);
    const speed= dt>0 ? dist/dt : 0;
    lastT[deviceId] = now;

    const norm = Math.min(1, speed/2000),
          w2   = MAX_W - (MAX_W-MIN_W)*norm,
          w1   = segments[deviceId].length
                 ? segments[deviceId].slice(-1)[0].w2
                 : (MIN_W+MAX_W)/2;

    if(isDrawing){
      segments[deviceId].push({ x1:prev.x, y1:prev.y, x2:x, y2:y, w1,w2 });
    }
    rawPos[deviceId] = {x,y};
  });

  // render-loop
  let pulse=0, grow=true;
  (function R(){
    ctx.clearRect(0,0,c.width,c.height);

    // zeichne alle devices
    for(let id in segments){
      const segs = segments[id];
      const col  = lastC[id] || "#f00";
      ctx.strokeStyle = col;

      for(let s of segs){
        const steps = 20;
        for(let i=0;i<steps;i++){
          const t0 = i/steps, t1=(i+1)/steps;
          const X0 = s.x1 + (s.x2-s.x1)*t0;
          const Y0 = s.y1 + (s.y2-s.y1)*t0;
          const X1 = s.x1 + (s.x2-s.x1)*t1;
          const Y1 = s.y1 + (s.y2-s.y1)*t1;
          const W  = s.w1 + (s.w2-s.w1)*t0;
          ctx.lineWidth = W;
          ctx.beginPath();
          ctx.moveTo(X0,Y0);
          ctx.lineTo(X1,Y1);
          ctx.stroke();
        }
      }
    }

    // pulsierender punkt
    pulse += grow?0.2:-0.2;
    if(pulse>2) grow=false;
    if(pulse<0) grow=true;

    for(let id in rawPos){
      const {x,y}= rawPos[id];
      const R  = ((segments[id]?.slice(-1)[0]?.w2)||MIN_W)/2 + pulse;
      ctx.fillStyle   = lastC[id]||"#f00";
      ctx.beginPath();
      ctx.arc(x,y,R,0,2*Math.PI);
      ctx.fill();
      if(lastL[id]<20){
        ctx.strokeStyle="#fff"; ctx.lineWidth=3;
        ctx.beginPath();
        ctx.arc(x,y,R+3,0,2*Math.PI);
        ctx.stroke();
      }
    }

    requestAnimationFrame(R);
  })();
  </script>
</body>
</html>
