<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.12 + dyn. Breite</title>
  <style>
    body { margin:0; background:black; }
    canvas { display:block; margin:auto; background:black; }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.12 (dyn. Breite, glatte Interp.)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.emit("identify", { role: "display", deviceId: null });

    const c    = document.getElementById("canvas"),
          ctx  = c.getContext("2d"),
          CX   = c.width/2,
          CY   = c.height/2;

    let MAX_H   = 20,
        MAX_V   = 20,
        SMOOTH  = 0.15;

    // neu: Threshold niedriger, damit breite Abstufung
    const SPEED_THRESHOLD = 600; 
    const MIN_W = 5,
          MAX_W = 12;

    // State pro Gerät
    const alpha0 = {}, beta0 = {},
          rawPos = {}, lastT = {},
          lastCol = {}, lastLight = {},
          segments = {}; // deviceId → [ {x1,y1,x2,y2,w1,w2,color}, … ]

    function parseLight(hsl){
      const m = hsl.match(/,\s*(\d+)%\)/);
      return m?+m[1]:50;
    }

    // clear
    socket.on("clear", () => {
      ctx.clearRect(0,0,c.width,c.height);
      for (let id in segments) segments[id] = [];
    });

    // motion
    socket.on("motion", ({alpha,beta,color,isDrawing,deviceId}) => {
      if (typeof alpha!=="number" || !deviceId) return;
      const now = performance.now();

      lastCol[deviceId]   = color;
      lastLight[deviceId] = parseLight(color);

      if (!(deviceId in rawPos)) {
        rawPos[deviceId] = {x:CX,y:CY};
        lastT[deviceId]  = now;
        segments[deviceId] = [];
        alpha0[deviceId] = null;
        beta0 [deviceId] = null;
      }

      // calibrate on first draw
      if (isDrawing && alpha0[deviceId]===null) {
        alpha0[deviceId] = alpha;
        beta0 [deviceId] = beta;
      }
      if (alpha0[deviceId]===null) return;

      // delta + wrap
      let dA = alpha - alpha0[deviceId];
      if (dA>180)  dA -= 360;
      if (dA<-180) dA += 360;
      let dB = beta - beta0[deviceId];
      dA = Math.max(-MAX_H,Math.min(MAX_H,dA));
      dB = Math.max(-MAX_V,Math.min(MAX_V,dB));

      // map to canvas
      const x = CX - (dA/MAX_H)*CX;
      const y = CY - (dB/MAX_V)*CY;

      // speed
      const prev = rawPos[deviceId],
            dt   = (now - lastT[deviceId])/1000,
            dist = Math.hypot(x-prev.x, y-prev.y),
            speed= dt>0? dist/dt : 0;
      lastT[deviceId] = now;

      if (isDrawing) {
        const norm = Math.min(1, speed/SPEED_THRESHOLD);
        const w2   = MAX_W - (MAX_W-MIN_W)*norm;
        // w1 aus letztem Segment
        const lastSeg = segments[deviceId].slice(-1)[0];
        const w1 = lastSeg ? lastSeg.w2 : (MIN_W+MAX_W)/2;

        segments[deviceId].push({
          x1: prev.x, y1: prev.y,
          x2: x,      y2: y,
          w1, w2,
          color
        });
      }

      rawPos[deviceId] = { x, y };
    });

    // render
    let pulse=0, grow=true;
    (function R(){
      ctx.clearRect(0,0,c.width,c.height);

      // Linien zeichnen mit glatter Interpolation
      for (let id in segments) {
        const segs = segments[id];
        ctx.strokeStyle = lastCol[id] || "#f00";
        for (let s of segs) {
          const steps = 20;
          for (let i=0;i<steps;i++){
            const t0 = i/steps, t1=(i+1)/steps;
            const X0 = s.x1 + (s.x2-s.x1)*t0;
            const Y0 = s.y1 + (s.y2-s.y1)*t0;
            const X1 = s.x1 + (s.x2-s.x1)*t1;
            const Y1 = s.y1 + (s.y2-s.y1)*t1;
            const W  = s.w1 + (s.w2-s.w1)*t0;
            ctx.lineWidth = W;
            ctx.beginPath();
            ctx.moveTo(X0,Y0);
            ctx.lineTo(X1,Y1);
            ctx.stroke();
          }
        }
      }

      // Pulsierender Punkt
      pulse += grow?0.2:-0.2;
      if (pulse>2) grow=false;
      if (pulse<0) grow=true;

      for (let id in rawPos) {
        const {x,y} = rawPos[id];
        const lastSeg = segments[id].slice(-1)[0];
        const baseW   = lastSeg? lastSeg.w2 : (MIN_W+MAX_W)/2;
        const r       = baseW/2 + pulse;

        ctx.beginPath();
        ctx.fillStyle = lastCol[id]||"#f00";
        ctx.arc(x,y,r,0,2*Math.PI);
        ctx.fill();

        if ((lastLight[id]||50)<20) {
          ctx.lineWidth   = 3;
          ctx.strokeStyle = "#fff";
          ctx.beginPath();
          ctx.arc(x,y,r+3,0,2*Math.PI);
          ctx.stroke();
        }
      }

      requestAnimationFrame(R);
    })();
  </script>
</body>
</html>
