<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.18</title>
  <style>
    body { margin:0; background:#000 }
    canvas { display:block; margin:auto; background:#000 }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; font-family:sans-serif;
      font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.18 (multi-user + advanced brushes)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.emit("identify", { role: "display", deviceId: null });

    const c   = document.getElementById("canvas"),
          ctx = c.getContext("2d"),
          CX  = c.width/2,
          CY  = c.height/2;

    // Live-Settings vom Admin
    let MAX_H   = 20,
        MAX_V   = 20,
        SMOOTH  = 0.15;
    socket.on("updateSettings", ({ maxH, maxV, smooth }) => {
      if (typeof maxH   === "number") MAX_H  = maxH;
      if (typeof maxV   === "number") MAX_V  = maxV;
      if (typeof smooth === "number") SMOOTH = smooth;
    });

    // State pro Gerät
    const alpha0    = {},   // Kalibrier-Nullpunkte
          beta0     = {},
          lastRaw   = {},   // Rohposition
          lastSm     = {},   // Geglättete Position
          lastCol   = {},   // Farbe
          lastLit   = {};   // Lightness

    ctx.lineCap  = "round";
    ctx.lineJoin = "round";

    // Clear vom Admin
    socket.on("clear", () => {
      ctx.clearRect(0, 0, c.width, c.height);
      for (let k in alpha0)    delete alpha0[k];
      for (let k in beta0)     delete beta0[k];
      for (let k in lastRaw)   delete lastRaw[k];
      for (let k in lastSm)    delete lastSm[k];
      for (let k in lastCol)   delete lastCol[k];
      for (let k in lastLit)   delete lastLit[k];
    });

    // Hilfsfunktion: HSL → Lightness
    function parseLight(hsl) {
      const m = hsl.match(/hsl\(\s*\d+,\s*\d+%,\s*(\d+)%\s*\)/);
      return m ? +m[1] : 50;
    }

    // Brush-Stempel entlang Pfad
    function stampBrush(brush, x0, y0, x1, y1, color) {
      const dx = x1 - x0, dy = y1 - y0;
      const dist = Math.hypot(dx, dy);
      if (dist < 0.5) return;  // zu kurz

      // Abstand zwischen zwei Stempeln
      const step = 6;
      const n = Math.max(1, Math.floor(dist/step));
      for (let i = 0; i <= n; i++) {
        const t = i/n;
        const x = x0 + dx*t;
        const y = y0 + dy*t;

        ctx.strokeStyle = color;
        ctx.fillStyle   = color;

        if (brush === 1) {
          // Ein Kreis
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, 2*Math.PI);
          ctx.fill();

        } else if (brush === 2) {
          // Eine kurze diagonale Linie orientiert an Bewegungsrichtung
          const angle = Math.atan2(dy, dx);
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(
            x - Math.cos(angle)*7.5,
            y - Math.sin(angle)*7.5
          );
          ctx.lineTo(
            x + Math.cos(angle)*7.5,
            y + Math.sin(angle)*7.5
          );
          ctx.stroke();

        } else if (brush === 3) {
          // Vier Punkte im Quadrat
          [ -5, 5 ].forEach(dx0 => {
            [ -5, 5 ].forEach(dy0 => {
              ctx.beginPath();
              ctx.arc(x + dx0, y + dy0, 1.5, 0, 2*Math.PI);
              ctx.fill();
            });
          });
        }
      }
    }

    // Bewegungsevent
    socket.on("motion", ({ alpha, beta, color, isDrawing, brush, deviceId }) => {
      if (!deviceId || typeof alpha !== "number") return;

      // Lightness und Farbe speichern
      lastLit[deviceId] = parseLight(color);
      lastCol[deviceId] = color;

      // Kalibrieren beim ersten Zeichnen
      if (isDrawing && !(deviceId in alpha0)) {
        alpha0[deviceId] = alpha;
        beta0 [deviceId] = beta;
      }
      if (!(deviceId in alpha0)) return;

      // Winkel-Delta + Wrap
      let dA = alpha - alpha0[deviceId];
      if (dA > 180)  dA -= 360;
      if (dA < -180) dA += 360;
      let dB = beta - beta0[deviceId];

      // Clamp
      dA = Math.max(-MAX_H, Math.min(MAX_H, dA));
      dB = Math.max(-MAX_V, Math.min(MAX_V, dB));

      // Map auf Canvas
      const rawX = CX - (dA/MAX_H)*CX;
      const rawY = CY - (dB/MAX_V)*CY;

      // Smoothing
      if (!(deviceId in lastSm)) {
        lastSm[deviceId] = { x:CX, y:CY };
        lastRaw[deviceId] = { x:CX, y:CY };
      }
      const s = lastSm[deviceId];
      s.x += (rawX - s.x)*SMOOTH;
      s.y += (rawY - s.y)*SMOOTH;

      // Zeichnen nur wenn gedrückt
      if (isDrawing) {
        // Stempeln entlang Pfad von letzter glatter Position → neue glatte Position
        const prev = lastSm[deviceId];
        stampBrush(brush, prev.x, prev.y, s.x, s.y, color);
      }

      // Positionen updaten
      lastRaw[deviceId] = { x:rawX, y:rawY };
      lastSm[deviceId] = s;
    });

    // Pulsierender Punkt-Loop
    let pulse=0, growing=true;
    function render() {
      // Punkt immer sichtbar
      pulse += growing?0.2:-0.2;
      if (pulse>2) growing=false;
      if (pulse<0) growing=true;

      for (let id in lastSm) {
        const { x,y } = lastSm[id];
        const col     = lastCol[id]||"#fff";
        const r       = 4 + pulse;

        // Punkt in Farbe
        ctx.beginPath();
        ctx.arc(x,y,r,0,2*Math.PI);
        ctx.fillStyle = col;
        ctx.fill();

        // Weißer Ring bei dunkel
        if (lastLit[id]<20) {
          ctx.beginPath();
          ctx.arc(x,y,r+3,0,2*Math.PI);
          ctx.strokeStyle = "#fff";
          ctx.lineWidth   = 3;
          ctx.stroke();
        }
      }

      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
