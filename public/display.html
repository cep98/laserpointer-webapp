<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v4.0 (Pixi v6 + MeshLine)</title>
  <style>
    body { margin:0; background:#000; }
    #version {
      position:absolute; top:10px; left:10px;
      color:#fff; font-family:sans-serif;
      font-size:14px; opacity:0.6; z-index:10;
    }
    #canvas-container {
      width:1024px; height:1024px;
      margin:auto; position:relative;
      top:50%; transform:translateY(-50%);
    }
  </style>
</head>
<body>
  <div id="version">v4.0 (Pixi v6 + MeshLine)</div>
  <div id="canvas-container"></div>

  <!-- PixiJS v6 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.8/browser/pixi.min.js"></script>
  <!-- pixi-meshline v5 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi-meshline/5.4.0/pixi-meshline.umd.js"></script>
  <!-- Socket.IO Client -->
  <script src="/socket.io/socket.io.js"></script>

  <script>
  window.addEventListener("load", () => {
    // ─ PIXI
    const app = new PIXI.Application({
      width:1024, height:1024,
      backgroundColor:0x000000,
      antialias:true,
      resolution: window.devicePixelRatio||1
    });
    document.getElementById("canvas-container").appendChild(app.view);
    const linesContainer = new PIXI.Container(),
          pulseGraphics  = new PIXI.Graphics();
    app.stage.addChild(linesContainer, pulseGraphics);

    // ─ Socket.IO
    const socket = io();
    socket.on("connect", () => {
      socket.emit("identify",{ role:"display", deviceId:socket.id });
    });

    // ─ Settings vom Admin
    let MAX_H=20, MAX_V=20, SMOOTH=0.15, MIN_W=5, MAX_W=12;
    socket.on("updateSettings", cfg => {
      if (typeof cfg.maxH   === "number") MAX_H  = cfg.maxH;
      if (typeof cfg.maxV   === "number") MAX_V  = cfg.maxV;
      if (typeof cfg.minW   === "number") MIN_W  = cfg.minW;
      if (typeof cfg.maxW   === "number") MAX_W  = cfg.maxW;
      if (typeof cfg.smooth === "number") SMOOTH = cfg.smooth;
    });

    // ─ State pro Gerät
    const state = {};
    function parseLight(hsl){
      const m = hsl.match(/,\s*(\d+)%\)/);
      return m?+m[1]:50;
    }

    // ─ Clear
    socket.on("clear", () => {
      linesContainer.removeChildren();
      pulseGraphics.clear();
      for(let id in state) delete state[id];
    });

    // ─ Motion
    socket.on("motion", ({alpha,beta,color,isDrawing,deviceId}) => {
      if (typeof alpha!=="number" || !deviceId) return;
      const now = performance.now(), CX=app.renderer.width/2, CY=app.renderer.height/2;

      let s = state[deviceId];
      if (!s) {
        s = state[deviceId] = {
          alpha0:null,
          beta0: null,
          smooth:{x:CX,y:CY,t:now},
          lastW:(MIN_W+MAX_W)/2,
          meshLine: new PIXI.MeshLine(),
          material:null,
          mesh:null,
          lastColor: color,
          lastLight: parseLight(color)
        };
      }

      // Update Farbe
      s.lastColor = color;
      s.lastLight = parseLight(color);

      // Calibrate
      if (isDrawing && s.alpha0===null) {
        s.alpha0 = alpha;
        s.beta0  = beta;
      }
      if (s.alpha0===null) return;

      // Delta+Wrap
      let dA = alpha - s.alpha0;
      if (dA>180)  dA-=360;
      if (dA<-180) dA+=360;
      let dB = beta - s.beta0;
      dA = Math.max(-MAX_H,Math.min(MAX_H,dA));
      dB = Math.max(-MAX_V,Math.min(MAX_V,dB));

      // Map to canvas
      const x = CX - (dA/MAX_H)*CX,
            y = CY - (dB/MAX_V)*CY;

      // Smooth
      s.smooth.x += (x - s.smooth.x)*SMOOTH;
      s.smooth.y += (y - s.smooth.y)*SMOOTH;

      // Speed→Width
      const dt    = (now - s.smooth.t)/1000,
            dx    = s.smooth.x - (s.prevX||s.smooth.x),
            dy    = s.smooth.y - (s.prevY||s.smooth.y),
            speed = dt>0?Math.hypot(dx,dy)/dt:0;
      s.smooth.t = now;
      s.prevX    = s.smooth.x;
      s.prevY    = s.smooth.y;

      if (isDrawing) {
        const norm = Math.min(1,speed/2000),
              w2   = MAX_W - (MAX_W-MIN_W)*norm,
              w1   = s.lastW;
        s.lastW = w2;

        if (!s.material) {
          const colHex = PIXI.utils.string2hex(s.lastColor);
          s.material = new PIXI.MeshLineMaterial({
            color: colHex,
            lineWidth: w2,
            resolution: { x:1024, y:1024 }
          });
          s.mesh = new PIXI.Mesh(s.meshLine, s.material);
          linesContainer.addChild(s.mesh);
        }
        const pts    = (s.meshLine.points||[]).concat([s.smooth.x, s.smooth.y]);
        const widths = (s.meshLine.widths||[]).concat([w1, w2]);
        s.meshLine.setPoints(pts,false,widths);
        s.material.uniforms.lineWidth = w2;
      }
    });

    // ─ Puls-Loop
    let pulse=0, grow=true;
    app.ticker.add(() => {
      pulse += grow?0.2:-0.2;
      if (pulse>2) grow=false;
      if (pulse<0) grow=true;

      pulseGraphics.clear();
      for (let id in state) {
        const s    = state[id],
              col  = PIXI.utils.string2hex(s.lastColor),
              light= s.lastLight,
              r    = s.lastW/2 + pulse;

        // Pulsierender Punkt
        pulseGraphics.beginFill(col);
        pulseGraphics.drawCircle(s.smooth.x, s.smooth.y, r);
        pulseGraphics.endFill();

        if (light<20) {
          pulseGraphics.lineStyle(3,0xffffff);
          pulseGraphics.drawCircle(s.smooth.x, s.smooth.y, r+3);
        }
      }
    });

  });
  </script>
</body>
</html>
