<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display (multi-user)</title>
  <style>
    body { margin:0; background:black; }
    canvas { display:block; margin:auto; background:black; }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.8 (multi-user)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    // melden als Display
    socket.emit("identify", { role: "display", deviceId: null });

    const c       = document.getElementById("canvas");
    const ctx     = c.getContext("2d");
    const CX      = c.width/2, CY = c.height/2;
    const MAX_H   = 20, MAX_V = 20;    // statisch oder per Admin-Settings
    const SMOOTH  = 0.15;              // optional per Admin

    // pro Gerät speichern wir den letzten Punkt
    const lastPos   = {};   // deviceId → { x, y }
    const segments  = [];   // alle Linien-Segmente über alle Geräte

    ctx.lineCap  = "round";
    ctx.lineJoin = "round";

    socket.on("motion", ({ alpha, beta, color, isDrawing, deviceId }) => {
      if (!deviceId) return;
      // Kalibrierung: wir initialisieren lastPos[deviceId] in der Mitte beim ersten Draw
      if (!(deviceId in lastPos)) {
        lastPos[deviceId] = { x: CX, y: CY };
      }

      // Winkel wrap-around
      let dA = alpha  - (alpha0Map?.[deviceId] ?? alpha);
      let dB = beta   - (beta0Map?.[deviceId]  ?? beta);

      // Wenn das erste Drawing, kalibrieren wir die Nullpunkte
      if (isDrawing && !alpha0Map) {
        alpha0Map = alpha0Map || {};
        beta0Map  = beta0Map  || {};
        alpha0Map[deviceId] = alpha;
        beta0Map[deviceId]  = beta;
        // reset dA/dB
        dA = 0; dB = 0;
      }
      // wrap
      if (dA>180) dA-=360;
      if (dA<-180)dA+=360;

      // clamp
      dA = Math.max(-MAX_H, Math.min(MAX_H, dA));
      dB = Math.max(-MAX_V, Math.min(MAX_V, dB));

      // map auf Canvas
      const x = CX - (dA/MAX_H)*CX;
      const y = CY - (dB/MAX_V)*CY;

      // wenn Zeichnen, füge Segment hinzu
      if (isDrawing) {
        const prev = lastPos[deviceId];
        segments.push({
          x1: prev.x, y1: prev.y,
          x2: x,     y2: y,
          color, deviceId
        });
      }

      // update lastPos
      lastPos[deviceId] = { x, y };
    });

    socket.on("clear", () => {
      segments.length = 0;
      ctx.clearRect(0,0,c.width,c.height);
      // reset
      for (let k in lastPos) delete lastPos[k];
      alpha0Map = {}; beta0Map = {};
    });

    // Hilfskarten für Kalibrier-Nullpunkte
    let alpha0Map = {}, beta0Map = {};

    // Render-Loop
    function render() {
      ctx.clearRect(0,0,c.width,c.height);
      // alle Segmente zeichnen
      for (const s of segments) {
        ctx.strokeStyle = s.color;
        ctx.lineWidth   = 6;
        ctx.beginPath();
        ctx.moveTo(s.x1, s.y1);
        ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      }
      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
