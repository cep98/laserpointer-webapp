<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.13+</title>
  <style>
    body { margin:0; background:black; }
    canvas { display:block; margin:auto; background:black; }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.13+</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  const socket = io();
  socket.emit("identify", { role:"display", deviceId:null });

  const canvas = document.getElementById("canvas"),
        ctx    = canvas.getContext("2d"),
        CX     = canvas.width/2,
        CY     = canvas.height/2;

  // Runden Kappen und Verbindungen
  ctx.lineCap  = "round";
  ctx.lineJoin = "round";

  // Admin-Overrides
  let MAX_H=20, MAX_V=20, SMOOTH=0.15, MIN_W=5, MAX_W=12;
  socket.on("updateSettings", ({maxH,maxV,smooth,minW,maxW})=>{
    if(typeof maxH==="number") MAX_H=maxH;
    if(typeof maxV==="number") MAX_V=maxV;
    if(typeof smooth==="number")SMOOTH=smooth;
    if(typeof minW==="number") MIN_W=minW;
    if(typeof maxW==="number") MAX_W=maxW;
  });

  // State pro Device
  const alpha0     = {},    // Kalibriernullpunkt
        beta0      = {},
        lastW      = {},    // letzte End-breite
        lastDraw   = {},    // letzter draw-Zustand (um newStroke zu erkennen)
        smoothPos  = {},    // glatte Pos für Pulse
        lastColor  = {},    // Farbe
        lastLight  = {};    // Helligkeit für Ring

  // Puls-Werte
  let pulse=0, growing=true;

  // Light-Parser
  function parseLight(hsl){
    const m=hsl.match(/,\s*(\d+)%\)/);
    return m?+m[1]:50;
  }

  socket.on("clear", ()=>{
    ctx.clearRect(0,0,1024,1024);
    // reset State
    [alpha0,beta0,lastW,lastDraw,smoothPos,lastColor,lastLight]
      .forEach(o=>Object.keys(o).forEach(k=>delete o[k]));
  });

  socket.on("motion", ({alpha,beta,color,isDrawing,deviceId})=>{
    if(typeof alpha!=="number"||!deviceId) return;
    const now = performance.now();

    // Farbe & Light
    lastColor[deviceId] = color;
    lastLight[deviceId] = parseLight(color);

    // New stroke? (lift & press)
    if(isDrawing && !lastDraw[deviceId]){
      // reset glatte Position und letzten Width
      smoothPos[deviceId] = { x:CX, y:CY, t:now };
      lastW[deviceId]     = (MIN_W+MAX_W)/2;
    }
    lastDraw[deviceId] = isDrawing;

    // Kalibrierung beim allerersten Draw
    if(isDrawing && !(deviceId in alpha0)){
      alpha0[deviceId]   = alpha;
      beta0 [deviceId]   = beta;
      smoothPos[deviceId] = { x:CX, y:CY, t:now };
      lastW[deviceId]    = (MIN_W+MAX_W)/2;
      return;
    }
    if(!(deviceId in alpha0)) return;

    // Winkel → delta + wrap-around
    let dA = alpha - alpha0[deviceId];
    if(dA > 180)  dA -= 360;
    if(dA < -180) dA += 360;
    let dB = beta - beta0[deviceId];
    // clamp
    dA = Math.max(-MAX_H, Math.min(MAX_H, dA));
    dB = Math.max(-MAX_V, Math.min(MAX_V, dB));
    // map to canvas coords
    const x = CX - (dA / MAX_H) * CX;
    const y = CY - (dB / MAX_V) * CY;

    // smoothing (für Pulse)
    const sp = smoothPos[deviceId];
    sp.x += (x - sp.x) * SMOOTH;
    sp.y += (y - sp.y) * SMOOTH;

    // Geschwindigkeit px/s
    const dt   = (now - sp.t)/1000;
    const dx   = x - sp.x;
    const dy   = y - sp.y;
    const speed= dt>0?Math.hypot(dx,dy)/dt:0;
    sp.t = now;

    // Strichstärke
    if(isDrawing){
      const norm = Math.min(1, speed/2000);
      const w2   = MAX_W - (MAX_W - MIN_W)*norm;
      const w1   = lastW[deviceId];
      // zeichnen
      ctx.strokeStyle = color;
      ctx.lineWidth   = w1;
      ctx.beginPath();
      ctx.moveTo(sp.x - dx, sp.y - dy);
      ctx.lineTo(sp.x, sp.y);
      ctx.stroke();
      lastW[deviceId] = w2;
    }
  });

  // Puls und Render-Loop
  ;(function render(){
    // Pulse aktualisieren
    pulse += growing?0.2:-0.2;
    if(pulse>2) growing=false;
    if(pulse<0) growing=true;

    // Pulsing-Punkt für jedes Gerät zeichnen
    for(const id in smoothPos){
      const {x,y} = smoothPos[id];
      const col   = lastColor[id] || "#fff";
      const light = lastLight[id] || 50;
      const r     = lastW[id]/2 + pulse;

      // Fill circle
      ctx.beginPath();
      ctx.fillStyle = col;
      ctx.arc(x,y, r, 0, Math.PI*2);
      ctx.fill();

      // Weißer Ring
      if(light<20){
        ctx.beginPath();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth   = 3;
        ctx.arc(x,y, r+3, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    requestAnimationFrame(render);
  })();
  </script>
</body>
</html>
