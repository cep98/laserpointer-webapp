<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.14</title>
  <style>
    body { margin:0; background:black }
    canvas { display:block; margin:auto; background:black }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.14 (smooth dynamic)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.emit("identify",{ role:"display", deviceId:null });

    const c   = document.getElementById("canvas"),
          ctx = c.getContext("2d"),
          CX  = c.width/2, CY = c.height/2;

    // Admin-Overrides
    let MAX_H=20, MAX_V=20, SMOOTH=0.15;
    socket.on("updateSettings",({maxH,maxV,smooth})=>{
      if(typeof maxH==="number") MAX_H=maxH;
      if(typeof maxV==="number") MAX_V=maxV;
      if(typeof smooth==="number") SMOOTH=smooth;
    });

    // State per device
    const alpha0     = {},
          beta0      = {},
          smoothPos  = {},    // geglättete Position
          lastTime   = {},
          lastCol    = {},
          lastLight  = {},
          devicePts  = {};    // deviceId → [{x,y,w,color},...]

    // Hilfe: Lightness parsen
    function parseLight(hsl){
      const m = hsl.match(/hsl\(\s*\d+,\s*\d+%,\s*(\d+)%\s*\)/);
      return m?+m[1]:50;
    }

    // Beim Clear alle Daten leeren
    socket.on("clear",()=>{
      ctx.clearRect(0,0,c.width,c.height);
      for(let k in alpha0)    delete alpha0[k];
      for(let k in beta0)     delete beta0[k];
      for(let k in smoothPos) delete smoothPos[k];
      for(let k in lastTime)  delete lastTime[k];
      for(let k in lastCol)   delete lastCol[k];
      for(let k in lastLight) delete lastLight[k];
      for(let k in devicePts) delete devicePts[k];
    });

    // Haupt-Handler
    socket.on("motion",({alpha,beta,color,isDrawing,deviceId})=>{
      if(!deviceId||typeof alpha!=="number") return;
      const now = performance.now();

      // 1) speichern
      lastCol[deviceId]   = color;
      lastLight[deviceId] = parseLight(color);

      // 2) kalibrieren beim ersten Draw
      if(isDrawing && !(deviceId in alpha0)){
        alpha0[deviceId]    = alpha;
        beta0 [deviceId]    = beta;
        smoothPos[deviceId] = { x:CX, y:CY };
        lastTime [deviceId] = now;
        devicePts[deviceId] = [];
        return;
      }
      if(!(deviceId in alpha0)) return;

      // 3) Winkel-Delta + Wrap
      let dA = alpha - alpha0[deviceId];
      if(dA>180)  dA-=360;
      if(dA<-180) dA+=360;
      let dB = beta - beta0[deviceId];

      // 4) clamp
      dA = Math.max(-MAX_H,Math.min(MAX_H,dA));
      dB = Math.max(-MAX_V,Math.min(MAX_V,dB));

      // 5) auf Canvas map
      const rawX = CX - (dA/MAX_H)*CX;
      const rawY = CY - (dB/MAX_V)*CY;

      // 6) glätten
      const sp = smoothPos[deviceId];
      sp.x += (rawX - sp.x)*SMOOTH;
      sp.y += (rawY - sp.y)*SMOOTH;

      // 7) Geschwindigkeit (px/s)
      const prev = smoothPos[deviceId],
            dt   = (now - lastTime[deviceId]) / 1000,
            dx   = sp.x - prev.x,
            dy   = sp.y - prev.y,
            speed= dt>0 ? Math.hypot(dx,dy)/dt : 0;
      lastTime[deviceId] = now;

      if(isDrawing){
        // 8) speed → width [2..12]
        const threshold = 2000; // px/s für minimal width
        const norm = Math.min(1, speed/threshold);
        const maxW = 12, minW = 2;
        const w = maxW - (maxW-minW)*norm;

        // 9) Punkt mit width pushen
        devicePts[deviceId].push({
          x: sp.x,
          y: sp.y,
          w,
          color
        });
      }
    });

    // Render-Loop
    let pulse=0, grow=true;
    function render(){
      ctx.clearRect(0,0,c.width,c.height);

      // Linien per Device zeichnen
      for(const id in devicePts){
        const pts = devicePts[id];
        if(pts.length<2) continue;
        ctx.strokeStyle = pts[0].color; // Farbe bleibt gleich pro Stroke
        for(let i=1;i<pts.length;i++){
          const p0 = pts[i-1],
                p1 = pts[i],
                w  = (p0.w + p1.w)/2;
          ctx.lineWidth = w;
          ctx.beginPath();
          ctx.moveTo(p0.x,p0.y);
          ctx.lineTo(p1.x,p1.y);
          ctx.stroke();
        }
      }

      // Puls
      pulse += grow?0.2:-0.2;
      if(pulse>2) grow=false;
      if(pulse<0) grow=true;

      // Punkte pulsen
      for(const id in smoothPos){
        const {x,y}=smoothPos[id];
        const pts = devicePts[id]||[];
        const lastW = pts.length?pts[pts.length-1].w:6;
        const r = lastW/2 + pulse;
        const col = lastCol[id]||"#fff";
        ctx.beginPath();
        ctx.arc(x,y,r,0,2*Math.PI);
        ctx.fillStyle = col;
        ctx.fill();
        if((lastLight[id]||50)<20){
          ctx.beginPath();
          ctx.arc(x,y,r+3,0,2*Math.PI);
          ctx.strokeStyle="#fff"; ctx.lineWidth=3; ctx.stroke();
        }
      }

      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
