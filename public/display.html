<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Laserpointer Display v3.18 (bezier redraw)</title>
  <style>
    body { margin:0; background:black; overflow:hidden }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif;
      font-size:14px; opacity:0.6; z-index:10;
    }
    canvas {
      display:block;
      margin:auto;
      background:black;
      position:absolute;
      top:0; left:0;
    }
    #container {
      position:relative;
      width:1024px; height:1024px;
      margin:auto;
    }
  </style>
</head>
<body>
  <div id="version">v3.18 (bezier redraw)</div>
  <div id="container">
    <canvas id="canvas" width="1024" height="1024"></canvas>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.emit("identify", { role:"display", deviceId:null });

    const canvas = document.getElementById("canvas"),
          ctx    = canvas.getContext("2d"),
          CX     = canvas.width/2,
          CY     = canvas.height/2;

    // Admin-Settings (werden live überschrieben)
    let MAX_H = 20, MAX_V = 20, MIN_W = 5, MAX_W = 12, SMOOTH = 0.15;
    socket.on("updateSettings", cfg => {
      if (typeof cfg.maxH   === "number") MAX_H  = cfg.maxH;
      if (typeof cfg.maxV   === "number") MAX_V  = cfg.maxV;
      if (typeof cfg.minW   === "number") MIN_W  = cfg.minW;
      if (typeof cfg.maxW   === "number") MAX_W  = cfg.maxW;
      if (typeof cfg.smooth === "number") SMOOTH = cfg.smooth;
    });

    const SPEED_THRESH = 2000; // px/s

    // State pro Gerät
    const alpha0    = {},   // Kalibrier-Nullpunkt α
          beta0     = {},   // Kalibrier-Nullpunkt β
          rawPos    = {},   // letzter Roh-Punkt {x,y}
          lastTime  = {},   // timestamp
          lastWidth = {},   // gestrichene Breite zuletzt
          wasDraw   = {},   // ob gezeichnet wurde
          prev1     = {},   // letzter gezeichneter Punkt
          prev2     = {},   // zweiter letzter gezeichneter Punkt
          lastColor = {},   // Farbe zuletzt
          lastLight = {},   // Helligkeit zuletzt
          segments  = [];   // {p0,p1,p2,color,width}

    // Hilfsfunktion zum Auslesen der Lightness aus "hsl(...,50%)"
    function parseLight(hsl) {
      const m = hsl.match(/,\s*(\d+)%\)/);
      return m ? +m[1] : 50;
    }

    // Reset bei Clear
    socket.on("clear", () => {
      segments.length = 0;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let id in rawPos) {
        delete rawPos[id];
        delete alpha0[id];
        delete beta0[id];
        delete lastTime[id];
        delete lastWidth[id];
        delete wasDraw[id];
        delete prev1[id];
        delete prev2[id];
        delete lastColor[id];
        delete lastLight[id];
      }
    });

    // Empfang neuer Bewegungsdaten
    socket.on("motion", ({alpha,beta,color,isDrawing,deviceId}) => {
      if (!deviceId || typeof alpha !== "number") return;
      const now = performance.now();

      // Farbe & Lightness merken
      lastColor[deviceId] = color;
      lastLight[deviceId] = parseLight(color);

      // Erst-Initialisierung
      if (!(deviceId in rawPos)) {
        rawPos[deviceId]   = { x:CX, y:CY };
        lastTime[deviceId] = now;
        lastWidth[deviceId]= (MIN_W + MAX_W)/2;
        wasDraw[deviceId]  = false;
        prev1[deviceId] = prev2[deviceId] = null;
        alpha0[deviceId] = beta0[deviceId] = null;
      }

      // Kalibrierung beim allerersten Zeichnen
      if (isDrawing && alpha0[deviceId] === null) {
        alpha0[deviceId] = alpha;
        beta0 [deviceId] = beta;
      }
      if (alpha0[deviceId] === null) return;

      // Winkel-Delta + Wrap-Around
      let dA = alpha - alpha0[deviceId];
      if (dA > 180)  dA -= 360;
      if (dA < -180) dA += 360;
      let dB = beta - beta0[deviceId];

      // Clamp
      dA = Math.max(-MAX_H, Math.min(MAX_H, dA));
      dB = Math.max(-MAX_V, Math.min(MAX_V, dB));

      // Auf Canvas-Koordinaten mappen
      const x = CX - (dA/MAX_H)*CX,
            y = CY - (dB/MAX_V)*CY;

      // Geschwindigkeit in px/s
      const prevRaw = rawPos[deviceId],
            dt      = (now - lastTime[deviceId]) / 1000,
            dist    = Math.hypot(x - prevRaw.x, y - prevRaw.y),
            speed   = dt>0 ? dist/dt : 0;
      rawPos[deviceId] = { x, y };
      lastTime[deviceId] = now;

      // Wenn Button neu gedrückt wurde, nicht verbinden
      if (isDrawing && !wasDraw[deviceId]) {
        prev1[deviceId] = prev2[deviceId] = null;
      }
      wasDraw[deviceId] = isDrawing;

      if (isDrawing) {
        // normierte Speed → rohes W [MIN_W..MAX_W]
        const norm  = Math.min(1, speed/SPEED_THRESH),
              rawW  = MAX_W - (MAX_W - MIN_W)*norm,
              wPrev = lastWidth[deviceId],
              wSmooth = wPrev + (rawW - wPrev)*SMOOTH;
        lastWidth[deviceId] = wSmooth;

        // History schieben
        prev2[deviceId] = prev1[deviceId];
        prev1[deviceId] = { x, y, w:wSmooth, color };

        // nur wenn wir drei Punkte haben, zeichnen
        if (prev2[deviceId]) {
          segments.push({
            p0: prev2[deviceId],
            p1: prev1[deviceId],
            p2: {x,y},
            color,
            width: wSmooth
          });
        }
      }
    });

    // Render-Loop: Bézier redraw + Puls-Punkt
    let pulse = 0, grow = true;
    (function render(){
      // 1) Kurve neu zeichnen
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.lineCap  = "round";
      ctx.lineJoin = "round";

      for (let s of segments) {
        ctx.strokeStyle = s.color;
        ctx.lineWidth   = s.width;
        ctx.beginPath();
        ctx.moveTo(s.p0.x, s.p0.y);
        ctx.quadraticCurveTo(s.p1.x, s.p1.y, s.p2.x, s.p2.y);
        ctx.stroke();
      }

      // 2) Puls-Punkt
      pulse += grow?0.2:-0.2;
      if (pulse>2) grow=false;
      if (pulse<0) grow=true;

      for (let id in rawPos) {
        const {x,y} = rawPos[id],
              col   = lastColor[id] || "#f00",
              r     = lastWidth[id]/2 + pulse;

        // Füllen
        ctx.beginPath();
        ctx.arc(x,y,r,0,2*Math.PI);
        ctx.fillStyle = col;
        ctx.fill();

        // Ring falls dunkel
        if ((lastLight[id]||50) < 20) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth   = 3;
          ctx.beginPath();
          ctx.arc(x,y,r+3,0,2*Math.PI);
          ctx.stroke();
        }
      }

      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
