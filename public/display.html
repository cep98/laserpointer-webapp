<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Laserpointer Display v3.13</title>
  <style>
    body { margin:0; background:black; }
    canvas { display:block; margin:auto; background:black; }
    #version {
      position:absolute; top:10px; left:10px;
      color:white; font-family:sans-serif; font-size:14px; opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="version">v3.13 (multi-user + brushes)</div>
  <canvas id="canvas" width="1024" height="1024"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    socket.emit("identify", { role:"display", deviceId:null });

    const c      = document.getElementById("canvas"),
          ctx    = c.getContext("2d"),
          CX     = c.width/2,
          CY     = c.height/2;

    // Default-Einstellungen
    let MAX_H   = 20, MAX_V = 20, SMOOTH = 0.15;

    // Pro Gerät: rohe und geglättete Positionen
    const rawPos    = {},   // deviceId→{x,y}
          smoothPos = {},   // deviceId→{x,y}
          lastColor = {},   // deviceId→HSL
          lastLight = {};   // deviceId→Lightness

    // Kalibrier-Nullpunkte
    const alpha0Map = {},
          beta0Map  = {};

    ctx.lineCap  = "round";
    ctx.lineJoin = "round";

    // Admin-Settings
    socket.on("updateSettings", ({ maxH, maxV, smooth }) => {
      if (typeof maxH  ==="number") MAX_H  = maxH;
      if (typeof maxV  ==="number") MAX_V  = maxV;
      if (typeof smooth==="number") SMOOTH = smooth;
    });

    // Clear
    socket.on("clear", () => {
      ctx.clearRect(0,0,c.width,c.height);
      for (let k in rawPos)    delete rawPos[k];
      for (let k in smoothPos) delete smoothPos[k];
      for (let k in lastColor) delete lastColor[k];
      for (let k in lastLight) delete lastLight[k];
      for (let k in alpha0Map) delete alpha0Map[k];
      for (let k in beta0Map)  delete beta0Map[k];
    });

    // Motion-Event mit brush
    socket.on("motion", ({ alpha, beta, color, isDrawing, brush, deviceId }) => {
      if (!deviceId || typeof alpha!=="number") return;

      // parse lightness
      const m = color.match(/hsl\([^,]+,\s*[^,]+,\s*(\d+)%\)/);
      const light = m ? parseInt(m[1],10) : 50;
      lastLight[deviceId] = light;
      lastColor[deviceId] = color;

      // Kalibrieren
      if (isDrawing && !(deviceId in alpha0Map)) {
        alpha0Map[deviceId] = alpha;
        beta0Map [deviceId] = beta;
        rawPos   [deviceId] = { x: CX, y: CY };
        smoothPos[deviceId] = { x: CX, y: CY };
      }
      if (!(deviceId in alpha0Map)) return;

      // Winkel-Delta
      let dA = alpha - alpha0Map[deviceId];
      if (dA>180) dA-=360;
      if (dA<-180)dA+=360;
      let dB = beta - beta0Map[deviceId];

      // clamp
      dA = Math.max(-MAX_H, Math.min(MAX_H, dA));
      dB = Math.max(-MAX_V, Math.min(MAX_V, dB));

      // map → rawPos
      const x = CX - (dA/MAX_H)*CX;
      const y = CY - (dB/MAX_V)*CY;
      rawPos[deviceId] = { x, y };

      // smoothing
      const sp = smoothPos[deviceId];
      sp.x += (x - sp.x)*SMOOTH;
      sp.y += (y - sp.y)*SMOOTH;

      // draw brush shape at sp.x, sp.y
      ctx.fillStyle   = color;
      ctx.strokeStyle = color;
      const R = 4;
      if (brush === 1) {
        // Punkt
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, R, 0, 2*Math.PI);
        ctx.fill();
      } else if (brush === 2) {
        // diagonale Linie 15px
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(sp.x - 7.5, sp.y - 7.5);
        ctx.lineTo(sp.x + 7.5, sp.y + 7.5);
        ctx.stroke();
      } else if (brush === 3) {
        // 4 Punkte 3px, Abstand 10px
        [ -5, 5 ].forEach(dx => {
          [ -5, 5 ].forEach(dy => {
            ctx.beginPath();
            ctx.arc(sp.x + dx, sp.y + dy, 1.5, 0, 2*Math.PI);
            ctx.fill();
          });
        });
      }

      // optional: weißen Ring bei dunklen Farben
      if (light < 20) {
        ctx.lineWidth   = 3;
        ctx.strokeStyle = "#fff";
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, R + 3, 0, 2*Math.PI);
        ctx.stroke();
      }
    });
  </script>
</body>
</html>
